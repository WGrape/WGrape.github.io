---
layout:     post
title:      一文掌握大模型应用的耗时优化方案（完整版）
header-img: /img/post.png
catalog: true
tags:
- 人工智能
- LLM
- 大模型应用开发
- 性能优化
---

> 文章内容更新请以 [WGrape GitHub博客 : 一文掌握大模型应用的耗时优化方案（完整版）](https://github.com/WGrape/Blog/issues/284) 为准

本文部分内容参考书籍《大模型应用落地：实战AI搜索》，此书籍在各大平台均有销售，如需本书籍请 [点击查看此书籍](https://item.jd.com/10169208264077.html) 。

<img width="1512" height="430" alt="微信图片_20250828163705_107_52" src="https://github.com/user-attachments/assets/c81190bb-b571-4fe2-ad6d-2bf92b88da15" />

***

# 前言
在构建大模型应用时，将大模型能力无缝融入既有系统是核心任务。然而，接口响应速度，往往是这个融合过程中面临的首要挑战。虽然我们可以沿用传统的工程优化手段，如弹性扩缩容、负载均衡、异步调用等，但它们并不能从根本上解决大模型推理本身的耗时问题。本文将深入探讨，如何通过大模型专属的优化方案，从根源上提升响应速度。

# 一、输入侧优化：从源头提速

为了有效解决大模型接口的耗时问题，我们必须从根本上重新审视任务设计。这不仅包括精简 Prompt 指令和减少上下文来降低模型的计算负担，更要灵活选择不同规模的模型。通过将任务分流给更轻量级的小模型，只让大模型处理那些真正需要其复杂能力的任务，我们能从源头大幅提升响应速度和效率，同时有效控制成本。

## 1.  **Prompt与上下文精简**

Prompt和上下文是模型推理的直接输入，所以Prompt 的长度直接影响大模型的推理速度。因此，优化输入是成本最低、效果最明显的加速手段。为了量化并验证输入长度对性能的影响，我们需要重点关注两个核心指标：

- Tokens Used (Token 使用量)：这是衡量输入规模的最直接指标。
- First Token Latency (首响延迟)：这反映了模型开始生成第一个 Token 所需的时间。

通过分析这两个指标，我们可以直观地验证输入长度与模型性能之间的关系。

### (1) 精简 Prompt
确保指令简洁、明确，只保留完成任务所必需的核心信息。请移除类似“请你耐心理解用户提问，不要着急”这类冗余的客套话或非必要描述，因为这些文本不仅不会提升模型性能，反而会徒增计算负担，拖慢响应速度。

下面我们以```deepseek-v3-250324```模型为例，在ChatBox应用中做出以下测试，可得出以下测量数据。分析测量数据可以得出，优化后的方案在 Token 消耗上从 862 降至 569，在首响延迟上从 1364.43ms 降至 747.57ms。这表明，通过精简Prompt可以有效的减少模型的计算负担，从而显著提升响应速度。如果是在更复杂的Prompt场景下，这个优化带来的提升会更加显著。

#### ① 优化前
```markdown 
## 角色
你是一个非常专业的广告文案撰写人，拥有丰富的电商运营经验，你的能力毋庸置疑。

## 要求
请你耐心理解我的需求，不要着急，仔细阅读我下面给出的广告文案撰写要求。
- 这次活动的名称是“清凉一夏”，这是文案的核心主题。
- 文案里一定要清楚地说明促销时间，比如从几号到几号。
- 我们这次有哪些主要折扣商品，包括服装、鞋子、防晒霜。
- 希望你能用一种富有创意、活泼、生动有趣且能吸引眼球的语言来撰写。
- 需要让消费者看到后立刻产生购买欲望，最好是那种让人眼前一亮的感觉。
- 请确保文案的语气是积极向上的，能够激发消费者的购物热情。
- 请注意文案的字数，最好控制在200字以内，这样才方便在各种社交媒体上发布，比如微博、小红书和朋友圈。

## 注意
- 这个广告文案对我来说至关重要，因为这关系到我们整个团队的业绩。
- 拜托你一定要写出让人眼前一亮的文案！我们全公司都指望你了！我相信你一定能完美完成！ 谢谢啦！

## 工作目标
请按照要求写出一个符合要求的广告文案，请务必给出一个满意的答案，感谢！
```

输出结果如下所示。

<img width="426" height="187" alt="image" src="https://github.com/user-attachments/assets/c9974d1a-832d-4e00-b899-b1d629e4455d" />

在经过7轮测试后，性能测试结果如下所示 ：

| ID | Time | Word Count | Token Count | Tokens Used | First Token Latency | Model |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1 | 16:55 | 200 | 394 | 916 | 1036ms | VolcEngine API (deepseek - v3 - 250324) |
| 2 | 16:55 | 174 | 334 | 856 | 1667ms | VolcEngine API (deepseek - v3 - 250324) |
| 3 | 16:56 | 145 | 282 | 804 | 1404ms | VolcEngine API (deepseek - v3 - 250324) |
| 4 | 16:56 | 188 | 363 | 885 | 1162ms | VolcEngine API (deepseek - v3 - 250324) |
| 5 | 16:56 | 167 | 343 | 865 | 1734ms | VolcEngine API (deepseek - v3 - 250324) |
| 6 | 16:57 | 147 | 299 | 821 | 1388ms | VolcEngine API (deepseek - v3 - 250324) |
| 7 | 16:58 | 187 | 362 | 884 | 1160ms | VolcEngine API (deepseek - v3 - 250324) |

根据提供的数据，我们可以计算出以下两个平均值：

1. 平均Token消耗数（Tokens Used）
- 总Token消耗数 = 916 + 856 + 804 + 885 + 865 + 821 + 884 = **6,031**  
- 平均Token消耗数 = 总Token消耗数 / 7 = **861.57**（约862 Tokens/次）

2. 平均首响时长（First Token Latency）
- 总首响时长 = 1036 + 1667 + 1404 + 1162 + 1734 + 1388 + 1160 = **9,551ms**  
- 平均首响时长 = 总首响时长 / 7 = **1,364.43ms**（约1.36秒/次）

#### ② 优化后
```markdown
## 角色
专业电商广告文案撰写人

## 关键信息
- 促销时间：[具体起止日期]
- 主推商品：
  • 服装（如T恤/短裤）
  • 鞋子（如凉鞋/拖鞋）
  • 防晒霜（全系列）

## 文案要求
- 风格：创意、活泼、高转化
- 效果：激发即时购买欲
- 字数：200字以内
- 适配平台：微博/小红书/朋友圈

## 任务
撰写"清凉一夏"促销活动广告文案
```

输出结果如下所示。

<img width="472" height="206" alt="image" src="https://github.com/user-attachments/assets/0057078c-7595-4192-8dee-baa10006fe96" />

在经过7轮测试后，性能测试结果如下所示 ：

| ID | Time | Word Count | Token Count | Tokens Used | First Token Latency | Model |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1 | 16:53 | 233 | 477 | 690 | 840ms | VolcEngine API (deepseek - v3 - 250324) |
| 2 | 17:12 | 164 | 334 | 535 | 609ms | VolcEngine API (deepseek - v3 - 250324) |
| 3 | 17:13 | 175 | 335 | 536 | 900ms | VolcEngine API (deepseek - v3 - 250324) |
| 4 | 17:14 | 183 | 320 | 521 | 732ms | VolcEngine API (deepseek - v3 - 250324) |
| 5 | 17:15 | 147 | 308 | 509 | 633ms | VolcEngine API (deepseek - v3 - 250324) |
| 6 | 17:15 | 235 | 413 | 614 | 963ms | VolcEngine API (deepseek - v3 - 250324) |
| 7 | 17:17 | 186 | 375 | 576 | 556ms | VolcEngine API (deepseek - v3 - 250324) |

根据提供的数据，我们可以计算出以下两个平均值：

1. 平均Token消耗数（Tokens Used）
- **总Token消耗数** = 690 + 535 + 536 + 521 + 509 + 614 + 576 = **3,981 Tokens**  
- **平均Token消耗数** = 总Token消耗数 / 7 = **568.71 Tokens/次**（约569 Tokens/次）  

2. 平均首响时长（First Token Latency）
- **总首响时长** = 840 + 609 + 900 + 732 + 633 + 963 + 556 = **5,233ms**  
- **平均首响时长** = 总首响时长 / 7 = **747.57ms**（约0.75秒/次）  

### (2) 减少上下文窗口
对于聊天机器人，不要无限制地将所有历史对话都作为上下文。可以设定一个最大轮次，如只保留最近的5-10轮对话，或采用**滑动窗口**机制，只保留最近的 N 个 token 作为上下文。

我们以 ```“Hello world ！“``` 这个提问为例，当分别在0轮次的上下文与10轮次的上下文中提问时，可得出以下测量数据。分析测量数据可以得出，随着上下文轮次的增加，Token 消耗和首响时间均呈增长趋势。当提问或回答的文本内容更长时，这种增长趋势会表现得更为显著。这表明，过多的上下文会增加模型的计算负担，从而影响响应效率。

#### ① 在0轮次上下文中提问

<img width="701" height="161" alt="image" src="https://github.com/user-attachments/assets/1db7fc19-7ce9-4c7b-93cd-05953965a0b7" />

| Time | Word Count | Token Count | Tokens Used | First Token Latency | Model |
| ---- | ---- | ---- | ---- | ---- | ---- |
| 14:01 | 8 | 19 | 37 | 963ms | VolcEngine API (deepseek - v3 - 250324) |

#### ② 在10轮次上下文中提问

<img width="750" height="219" alt="image" src="https://github.com/user-attachments/assets/6e48395b-45fd-4084-a844-1301ab864488" />

| ID | Time | Word Count | Token Count | Tokens Used | First Token Latency | Model |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1 | 14:01 | 77 | 139 | 5422 | 1698ms | VolcEngine API (deepseek - v3 - 250324) |

### (3) 摘要与压缩
利用**摘要模型**或**关键词提取**技术，对过长的历史对话进行压缩。将前几轮对话的精华提取成一个简短的摘要，再将其作为 Prompt 的一部分，而不是完整地传入所有历史记录。

在处理多轮次的长历史对话时，我们进行了一项实验，将未经优化的完整历史对话与经过摘要和压缩处理后的对话作为输入，对比了它们的性能表现。分析测量数据可以得出，优化后的方案在 Token 消耗上从 2294 降至 838，在 首响延迟上从 1433ms 降至 981ms。这表明，对冗长的历史对话进行摘要与压缩，能够有效减少模型的计算负担，从而显著提升响应速度。

#### ① 优化前
```
## 角色
你是一个智能问答助手。

## 历史消息
User ：水的沸点是多少摄氏度？（标准大气压下）
AI ：在标准大气压（1个大气压，约101.325 kPa）下，纯水的沸点是 100°C。这一数值是国际单位制（SI）中的标准参考值，由水的相变热力学性质决定。需要注意的是，沸点会受气压影响——例如在高海拔地区，气压较低，水的沸点会下降（如珠穆朗玛峰顶沸点仅约70°C）。此外，溶解物质（如盐）也会通过 沸点升高效应 改变沸点，这是烹饪中加盐使食物更快煮熟的科学原理。

User ：如果海拔升高500米，水的沸点会下降多少度？（提示：每升高300米降1°C）
AI ：根据高度与沸点的经验关系：
计算比例：500米 ÷ 300米/°C ≈ 1.67倍
沸点下降值：1.67 × 1°C ≈ 1.67°C
修正说明：实际应用中需考虑当地气压梯度，此估算假设温度随高度线性变化（国际标准大气模型）。例如在拉萨（海拔3650米），沸点约为88°C，与理论值基本一致。此原理对登山者规划炊具和实验室校准仪器至关重要。

User ：用比喻手法解释"高压锅如何改变沸点"，要求包含物理学原理。
AI ：高压锅如同一个"微观气候制造机"：
比喻解释：
普通锅像开放平原，水分子轻易逃逸（沸腾）；
高压锅则像深谷盆地，锅盖形成"人造高压大气层"，迫使水分子需要更高能量才能突破（沸点升高）。
科学原理：
密封设计使蒸汽无法逸出，锅内压力升至约2倍大气压（200 kPa）；
根据沸点-压力关系，此时水的沸点升至约 120°C（比常压高20°C）；
高温加速食物分子运动，使炖煮效率提升3倍以上。
延伸联想：这与地壳深处的"超临界水"形成机制异曲同工。

User ：人体正常体温范围是多少？
AI ：健康成年人的正常体温范围为 36.5°C~37.5°C（腋下测量略低，约36.0°C37.0°C）。这一范围由下丘脑体温调节中枢控制，但受昼夜节律（清晨最低，傍晚最高）、运动状态和测量部位影响。例如，直肠温度通常比口腔高0.3°C0.6°C。超过37.8°C可能提示低热，而低于35.0°C则属低体温症。

User ：如何快速缓解轻微烫伤？
AI ：轻微烫伤（皮肤发红但未起泡）可采取以下步骤：
立即冷却：用流动的冷水冲15-20分钟，或浸泡在冷水中（避免冰敷，可能冻伤）。
清洁保护：轻拍干后涂凡士林或烫伤膏，用无菌纱布覆盖（不要用牙膏/酱油等偏方）。
止痛处理：可口服布洛芬缓解疼痛，避免弄破潜在水泡。
若烫伤面积大于手掌或起大水泡，需就医。

User ：买空调时，变频和定频有什么区别？怎么选？
AI ：[选购指南] 关键对比与选择建议：
变频空调：
优点：温度稳定更省电（长期开推荐），噪音低（适合卧室）。
缺点：价格高，维修成本略高。
定频空调：
优点：价格便宜，适合短时间使用（如客厅偶尔开）。
缺点：启停时耗电高，温差波动明显。
选择原则：
卧室/常用空间选变频；预算有限或临时使用选定频。注意看能效标识（一级最省电）。

User ：衣服沾上油渍，怎么紧急处理？
[应急方案] 分材质处理：
普通棉质：
撒玉米淀粉/面粉吸油，静置10分钟后刷掉。
涂洗洁精（原液）搓洗，冷水冲洗。
丝绸/羊毛：
用棉签蘸甘油轻擦，再用中性洗涤剂清洗。
禁忌：勿用热水（固化油渍）、勿大力揉搓（损伤纤维）。

User ：怎么防止切洋葱时流泪？
AI ：多方案任选：
物理法：戴泳镜/护目镜隔绝气体。
化学法：切前冷藏洋葱10分钟（低温降低酶活性）。
技巧法：保持刀锋利（减少细胞破裂），旁边放一碗水吸附刺激性气体。

User ：门锁生锈转不动，怎么临时解决？
AI ： 三步法：
润滑：喷WD-40或滴食用油，静置5分钟。
松动：轻轻来回转动钥匙（勿暴力）。
清洁：锈屑擦净后涂铅笔芯粉（石墨润滑）。
若仍卡死，联系物业或锁匠。

## 用户提问
使用上下文中的知识，你刚才说轻微烫伤，如果使用立即冷却，应该用流动的冷水冲多少分钟 ？
```

<img width="1342" height="155" alt="image" src="https://github.com/user-attachments/assets/bc1e611f-e7fb-46b0-bda4-7ddb5cecc4c0" />

| ID | Time | Word Count | Token Count | Tokens Used | First Token Latency | Model |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1 | 14:26 | 230 | 367 | 2294 | 1433ms | VolcEngine API (deepseek - v3 - 250324) |

#### ② 优化后

```markdown
## 角色
你是一个智能问答助手。

## 历史消息
### 压缩版上下文总结

#### 核心知识点提取
1. 物理/化学原理
   - 水的沸点：标准大气压下为100°C，海拔每升高300米降1°C（如500米降约1.67°C）。  
   - 高压锅原理：密封增压使沸点升至120°C，类比“微观气候制造机”。  

2. 健康与生活技巧
   - 正常体温：36.5°C~37.5°C（腋下略低），直肠温度偏高。  
   - 烫伤处理：冷水冲15分钟→涂凡士林→覆盖纱布（禁用牙膏/酱油）。  
   - 切洋葱防流泪：冷藏10分钟/戴护目镜/保持刀锋利。  

3. 购物与维修建议
   - 空调选择：变频（省电静音）vs 定频（低价），卧室选变频。  
   - 油渍清洁：棉质用洗洁精，丝绸用甘油+中性洗涤剂。  
   - 生锈门锁：WD-40润滑→轻转钥匙→涂铅笔粉。  

#### 关键注意事项
- **科学修正**：沸点计算需考虑实际气压梯度（如拉萨3650米沸点88°C）。  
- **禁忌提醒**：烫伤禁用冰敷/偏方，油渍禁用热水揉搓。  
- **应急边界**：烫伤面积＞手掌或锁具卡死需专业处理。  

#### 压缩逻辑
- 保留**数据结论**（如数值、步骤）、**对比原则**（如变频/定频）、**禁忌项**。  
- 省略冗长解释（如公式推导、比喻细节），仅留结论性描述。  

## 用户提问
使用上下文中的知识，你刚才说轻微烫伤，如果使用立即冷却，应该用流动的冷水冲多少分钟 ？
```

<img width="721" height="62" alt="image" src="https://github.com/user-attachments/assets/23d0d73d-131a-4cbc-8d02-6af9356f2d71" />

| ID | Time | Word Count | Token Count | Tokens Used | First Token Latency | Model |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1 | 14:28 | 69 | 122 | 838 | 981ms | VolcEngine API (deepseek - v3 - 250324) |

## 2.  **大模型与小模型混合使用**
大模型功能虽强大，但 **“杀鸡用牛刀”** 式的资源浪费不可取。明智的策略是，将合适的任务分流给更轻量、响应更迅捷的小模型，让大模型专注于真正需要其复杂能力的挑战，以此实现性能与成本的最佳平衡。

### (1) 任务路由与分发
在调用大模型之前，先使用一个简单、快速的**小模型**（如各个模型的Lite等版本）进行处理。例如，判断用户意图、对问题进行分类。对于一些简单、高频的任务（如问候、闲聊、数据提取等），直接由小模型处理并返回，**避免不必要的的大模型调用**。

当任务分流给更轻量级的模型时，性能提升非常显著。我们对比测试了豆包模型（doubao）和其轻量版本（doubao-1.5-lite），得出了以下数据。从数据中可以清晰地看到，将任务路由至 doubao-1.5-lite 后，响应时间从 2719ms 显著降低至 779ms，而 Token 消耗几乎保持不变（从 407 变为 402）。这有力证明了根据任务需求选择不同规模的模型，在保持回答质量的同时，能够大幅提升响应速度，同时有效控制成本。

#### ① 优化前
```markdown
## 问题分类器
你是一个问题分类器，可以识别用户的问题属于什么类目
## Context
- 自然科学与工程技术：如物理与天文、化学与材料、生命科学与环境、计算机与信息技术
- 数学与逻辑学：如基础数学、高等数学、逻辑思维
- 人文学科：文学与创作、语言学与交流、历史与文化、哲学与思想、艺术与审美
- 社会科学：政治与法律、经济与管理、社会学与人类学、心理学与行为科学、医学
- 生活与实用技能：教育与学习、生活与健康、运动与休闲、职业与创业
- 交流与互动：日常对话
## Constrains
1. 返回结构如下所示
{
    "category": ""
}
## Workflow
1. 认真理解用户输入的内容先判断用户是在和你打招呼，和你简单的聊天，还是在向你提问
2. 从<Context>中选择一个合适的类目，标记此用户的问题的所属类目
3. 按要求返回结果
## 用户提问
你好
```

<img width="587" height="128" alt="image" src="https://github.com/user-attachments/assets/e1dffc80-e385-4a16-b06a-d1087b9e6785" />

| ID | Time | Word Count | Token Count | Tokens Used | First Token Latency | Model |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1 | 14:52 | 11 | 30 | 407 | 2719ms | VolcEngine API (doubao) |

#### ② 优化后

```markdown
## 问题分类器
你是一个问题分类器，可以识别用户的问题属于什么类目
## Context
- 自然科学与工程技术：如物理与天文、化学与材料、生命科学与环境、计算机与信息技术
- 数学与逻辑学：如基础数学、高等数学、逻辑思维
- 人文学科：文学与创作、语言学与交流、历史与文化、哲学与思想、艺术与审美
- 社会科学：政治与法律、经济与管理、社会学与人类学、心理学与行为科学、医学
- 生活与实用技能：教育与学习、生活与健康、运动与休闲、职业与创业
- 交流与互动：日常对话
## Constrains
1. 返回结构如下所示
{
    "category": ""
}
## Workflow
1. 认真理解用户输入的内容先判断用户是在和你打招呼，和你简单的聊天，还是在向你提问
2. 从<Context>中选择一个合适的类目，标记此用户的问题的所属类目
3. 按要求返回结果
## 用户提问
你好
```

<img width="572" height="125" alt="image" src="https://github.com/user-attachments/assets/b2312d2f-25ef-46b6-947d-4b7242a273ca" />

| ID | Time | Word Count | Token Count | Tokens Used | First Token Latency | Model |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1 | 14:47 | 7 | 25 | 402 | 779ms | VolcEngine API (doubao-1.5-lite) |

### (2) **信息提取与摘要**
当需要大模型处理复杂任务时，可以先用小模型对长文本进行摘要或提取关键信息，再将精炼后的内容作为**Prompt**输入给大模型。这样不仅能减少大模型的输入长度，还能显著降低推理耗时和成本。

我们以上面```Prompt与上下文的摘要与压缩```为例，在保证信息摘要质量的前提下，我们通过将任务分流给轻量级模型，显著提升了响应速度。以下是使用豆包模型（doubao）和其轻量版本（doubao-1.5-lite）进行测试后的对比数据。从数据中可以清晰地看到，当使用 doubao-1.5-lite 模型后，响应速度从 1073ms 降低到了 681ms。这有力证明了在处理如信息摘要这类特定任务时，选择更小、更快的模型版本，能够在不牺牲核心功能的前提下，大幅提升用户体验。

#### ① 优化前

<img width="934" height="170" alt="image" src="https://github.com/user-attachments/assets/ba1c44f6-0a4d-40d5-a3bd-c1c987dcc1fd" />

| ID | Time | Word Count | Token Count | Tokens Used | First Token Latency | Model |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1 | 15:49 | 259 | 452 | 2351 | 1073ms | VolcEngine API (doubao) |

#### ② 优化后

<img width="1172" height="170" alt="image" src="https://github.com/user-attachments/assets/cb5778bc-5992-4884-89cf-2c0de2f48949" />

| ID | Time | Word Count | Token Count | Tokens Used | First Token Latency | Model |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1 | 15:52 | 393 | 630 | 2529 | 681ms | VolcEngine API (doubao-1.5-lite) |

# 二、应用侧优化：在效率与用户感知间求平衡

除了在模型输入侧下功夫，我们还能在应用层面找到提速的突破口。这些优化策略无需修改模型本身，但能显著提升用户体验和系统吞吐量。

## 1、应用层缓存

### (1) 相似Query缓存

传统的缓存机制依赖于精确匹配（如 Key-Value 存储），即只有当查询字符串完全一致时才能命中缓存。然而，在大模型应用中，用户提出的问题往往具有多样性，例如“如何重置密码？”和“我忘记密码了怎么办？”虽然语义相同，但在传统缓存中会被视为不同的查询。

为了解决这一问题，我们就需要引入Milvus这类向量数据库。将用户的提问Query用Embedding模型做向量计算，然后把向量结果作为Key，答案作为Value存储到向量数据库中。当新请求到来时，先通过向量相似度检索来判断是否存在历史答案。如果命中，直接返回缓存结果。在这一过程中，主要工作原理如下所示。

- 向量化：当新用户发起提问（query）时，系统会使用一个 Embedding 模型将其转换为高维度的向量表示。
- 向量检索：系统将这个向量作为查询键，在 Milvus 等向量数据库中进行相似度检索。它不是寻找精确匹配的文本，而是查找与其向量距离最近（即语义最相似）的历史查询。
- 智能命中：如果检索到的相似度超过预设阈值，系统即判断为缓存命中，并直接返回对应的历史答案。
- 未命中处理：如果未找到相似结果，请求将发送给大模型生成新答案。随后，系统会将这个新的“向量-答案”对存储到向量数据库中，以供后续查询使用。

虽然引入缓存是优化大模型响应速度的有效工程手段，但它也带来了一个新的挑战：答案多样性缺失。众所周知，大模型具有一定的随机性，即使面对相同的输入，也可能产生略有差异的输出，而这正是其创造力的体现。然而，缓存机制会固化答案，导致对同一问题的重复查询总是返回相同的结果，从而失去了大模型固有的多样性和灵活性。所以，下面我们将主要解如何平衡答案的多样性。


### (2) 平衡答案多样性
为了避免缓存导致答案单一，可以采用设置缓存有效期（TTL）、概率性缓存命中或缓存多样化处理等策略。

#### ① 设置缓存有效期 (TTL)
为缓存中的答案设置一个生存时间（Time-to-Live）。当答案超过有效期后，即使再次遇到相同的查询，系统也会强制绕过缓存，重新调用大模型生成新的答案。

#### ② 概率性缓存命中
我们可以设定一个缓存命中概率。例如，将命中率设置为 80%，这意味着有 80% 的机会返回缓存答案，而剩下的 20% 则会强制调用大模型，从而确保一定比例的请求能够获得新鲜、多样的答案。

#### ③ 缓存多样化处理

为了在响应速度和答案多样性之间取得平衡，我们可以引入一个答案多样性处理器。这个处理器的工作是在缓存命中的基础上，对固化的答案进行适度丰富和改写，而无需重新调用大模型。这个处理器的工作是，在不改变核心信息的前提下，对缓存答案进行适度的丰富和改写。例如，它可以：

- 替换同义词：将句子中的词语替换为近义词。
- 调整句式：改变句子的结构，如将陈述句改为疑问句或反问句。
- 增加修饰语：在不改变原意的情况下，加入一些修饰性的词语。

通过这种方式，我们既能获得缓存带来的高效率，又能为用户提供更丰富的回答体验。

### 2、流式传输

流式传输是一种“边生成，边返回”的交互模式。虽然它并不能缩短大模型完成任务的总耗时，但通过让用户看到内容实时生成，它能极大地降低用户的感知延迟。与其让用户盯着空白屏幕或加载动画等待，不如将等待过程转化为一个流畅、动态的实时生成体验。

下面，我们讲解下这种交互模式，它主要依赖于服务器与客户端之间的推拉机制。
- 拉模式（Pull）：客户端主动向服务器发送请求，服务器返回响应。在非流式模式下，客户端必须等待大模型生成完整结果后，才能一次性获取所有数据。
- 推模式（Push）：服务器主动向客户端推送数据，无需客户端发起请求。这是流式传输的核心，它允许服务器在数据生成时立即发送给客户端。

实现服务器端推送，需要后端技术具备支持长连接和持续数据发送的能力。常见的技术包括 WebSocket 和 HTTP 流式传输（Streaming）。虽然 HTTP 流式传输在交互上类似于真正的服务器推送，但其本质是一种“伪推送”。它利用了 HTTP 协议的特性，保持连接开放，并持续分块发送数据，直到内容全部传输完毕。而 WebSocket 则是一种更为彻底的双向通信协议，更适合需要频繁、实时交互的场景。

HTTP流式接口（Streaming）和普通HTTP接口在请求和响应头的处理上有显著差异，主要表现如下所示。

| 特性 | 普通 HTTP 接口 | HTTP 流式接口 |
| :--- | :--- | :--- |
| **数据传输模式** | 一次性传输 | 分块、持续传输 |
| **`Accept` 请求头** | 客户端期望的媒体类型，例如 `application/json` | 客户端期望的媒体类型，例如 `text/event-stream` |
| **`Content-Type` 响应头**| 指定响应数据的媒体类型 | 指定流媒体类型，例如 `text/event-stream` |
| **`Content-Length` 响应头** | **有**，表示总字节数 | **无**，无法预知总长度 |
| **`Transfer-Encoding` 响应头** | 通常无 | **`chunked`** |
| **`Connection` 响应头** | 通常为 `close` 或 `keep-alive` | 必须为 `keep-alive` |
| **响应时机** | 数据全部处理完毕后一次性返回 | 边处理边返回 |

### 3、流式解析代替JSON解析

在大模型应用中，我们常常需要模型返回结构化的数据，最常见的就是 JSON 格式。例如，一个用于信息提取的 Prompt，我们可能希望它返回以下结构：
```json
{
    "name": "xxx",
    "age": "xxx",
    "school": "xxx",
    "hobby": "xxx"
}
```

然而，这种传统的 JSON 格式有一个致命的缺点：我们必须等待整个 JSON 对象完整返回后，才能开始解析。这与流式传输的“边生成，边返回”理念相悖，导致用户必须等待整个数据传输完毕，才能看到最终结果，从而损失了流式输出带来的快速响应优势。

为了解决这个问题，我们可以采用流式解析的方式。与其让模型生成完整的 JSON，不如让它输出一种更适合逐行解析的格式。例如，我们可以将 JSON 结构转换成更简单的 Key-Value 文本格式。其格式如下所示：
```
name: xxx
age: xxx
school: xxx
hobby: xxx
```

在解析此格式的过程中，工作原理如下所示：
1. 逐行输出：模型在生成数据时，每完成一个属性（如 name: xxx），就立即将其作为一行数据输出。
2. 代码解析：客户端代码同步接收并缓存这些数据。每当接收到一个换行符时，就将其视为一个完整的属性，并立即进行解析。

通过这种方式，我们无需等待整个数据流完成，就能即时获取和处理每一条信息。这不仅解决了传统 JSON 解析的局限性，还将流式传输的优势发挥到了极致，大幅提升了用户感知的响应速度，特别是在处理大量结构化数据时，效果尤为显著。

# 三、模型推理优化：针对不同部署场景

模型推理优化策略因部署方式的不同而有显著差异。

## 1、自部署大模型：深度挖掘性能

当你选择自部署大模型时，你拥有完整的优化控制权。面对轻松突破万亿参数的 **Transformer** 和 **MoE (Mixture of Experts)** 架构，传统的优化方式已力不从心。此时，你需要借助一系列模型压缩技术，从根本上降低部署成本并提升推理速度。

### (1) 模型剪枝（Pruning）
- **原理**：大模型的参数并非都同等重要。剪枝技术通过识别并移除模型中不重要、对最终结果影响微乎其微的权重或神经元，从而减小模型规模。
- **应用**：你可以将一个万亿参数的模型裁剪成百亿甚至数十亿级别，显著减小模型体积，降低显存占用，并提升计算效率。

### (2) 知识蒸馏（Knowledge Distillation）
- **原理**：这是一种“以大带小”的压缩方法。它使用一个庞大的“教师模型”来训练一个更小、更快的“学生模型”。学生模型通过模仿教师模型的输出，学习其强大的泛化能力，从而在保持高精度的同时，大幅缩小模型尺寸。
- **应用**：你可以用一个超万亿参数的 MoE 模型作为教师，训练一个百亿参数的 Transformer 模型。这个学生模型能够继承教师模型的优秀性能，但推理速度和部署成本却远低于教师模型。

### (3) 模型量化（Quantization）
- **原理**：量化技术将模型参数和计算从高精度的浮点数（如 `float32`）转换为低精度的整数（如 `int8`）。
- **应用**：这能直接将模型体积缩小数倍，并利用现代硬件（如 GPU）对低精度计算的优化，实现推理速度的飞跃。例如，将一个 **`float32`** 的模型量化为 **`int8`** 后，其推理速度可能提升 2-4 倍，同时显著降低显存占用。


### (4) 高性能推理引擎
- **原理**：**vLLM** 这类专为大模型设计的推理引擎，通过 **PagedAttention** 等创新技术，解决了 Transformer 模型推理中键值缓存（KV Cache）的内存碎片化问题，从而极大地提高了**吞吐量**和 GPU 利用率。
- **应用**：结合上述模型压缩技术，再使用高性能推理引擎进行部署，能够最大化模型的性能潜力，实现更高的并发和更低的延迟。

## 2、云平台大模型服务：聚焦服务配置

如果你使用的是云平台的大模型服务（如阿里云、火山等），你无法直接修改模型或推理引擎。此时的优化重点在于服务配置与成本控制。

### (1) 按需选择
云平台通常提供多样化的大模型服务，不仅仅是通用的版本，还包括针对不同场景优化的模型。例如，你会看到不同规模、性能和成本的模型版本，如轻量版、通用版和专业版等。此外，一些平台还会提供特定功能的模型，例如专为角色扮演、内容摘要或代码生成而优化的模型。

在满足业务需求的前提下，选择一个更小、更合适、更轻量级的模型是提升效率和控制成本的关键。

### (2) 模型扩容

当系统面临流量激增，而现有资源无法满足高并发需求时，最直接、最可靠的解决方案就是为模型服务付费扩容。云服务商通常会提供不同等级的服务套餐，让用户可以根据业务需求灵活地提升模型接口的并发额度和优先级。

# 四、系统架构优化：异步处理与拆解并行

在宏观的系统架构层面，通过精心的任务编排和并行处理，我们可以从底层设计上缓解大模型接口的耗时问题，尤其是在处理复杂或耗时任务时。

## 1、异步化处理

在构建大模型应用时，并非所有任务都适合同步处理。对于那些耗时较长的生成类任务，如生成 AI 图片、AI 动画或完整的 PPT 文稿，让用户实时等待是不现实的。这种情况下，将任务转为异步处理是一种极具价值的设计模式，它能将用户请求与大模型的实际处理过程解耦，从而极大地优化用户体验。

无论是什么大模型的应用场景，长耗时的任务在异步化处理的这个过程中，都主要包括如下阶段。

1. **即时反馈**：当用户提交一个耗时任务（如“生成一部 10 分钟的 AI 动画”）时，系统应立即返回一个成功提交的响应，而非让用户等待。这个响应可以是简单的消息提示，如"提交成功，请稍后查看"，并提供一个任务ID，让用户知道请求已被接收。

2. **后台处理**：任务随后被发送到后台的消息队列（如 Kafka 或 RabbitMQ），由专门的消费服务进行处理。这个过程完全在后台进行，不会阻塞用户的操作。

3. **任务完成通知**：当大模型完成任务后，系统会通过预设的机制主动通知用户。这个通知可以是应用内的系统通知、弹窗提醒、或短信等，告知用户任务已完成，并提供查看或下载的链接。

## 2、复杂任务拆解与并行

对于需要多个步骤才能完成的复杂任务，我们可以将其分解为一系列更小、更简单的子任务。如果这些子任务能够独立或部分独立地执行，就可以通过并行化来大幅减少总耗时。这是一种“分而治之”的策略，能显著提升系统的处理效率。

这种任务拆解与并行化的设计模式，不仅是提升性能的关键，更能显著优化大模型生成结果的质量。通过将一个复杂任务拆解成多个单一目标的子任务，每个子任务都能更专注地完成特定目标，最终将所有高质量的子结果整合，从而生成一个更精确、更全面的最终答案。在这个过程中，主要包括以下几个阶段：

1. **任务拆解**：将一个大型、复杂的任务，按照其逻辑功能或处理步骤，分解为多个单一、独立的子任务。例如，将“生成一份包含多种元素的营销报告”分解为“撰写文案”、“生成图片”、“编写视频脚本”等。
2. **并行执行**：系统同时启动所有相互独立的子任务。这些子任务可以分配给不同的模型实例、不同的服务或不同的计算资源，从而同时进行处理，而不是依次等待。
3. **结果整合**：当所有并行子任务完成后，一个主控服务或另一个大模型将收集所有子任务的输出结果。它负责将这些高质量、专注度高的局部结果进行统一、整合和最终润色。
4. **最终交付**：将整合后的最终成果交付给用户。

然而，需要注意的是，并非所有任务都适用于并行处理。对于存在数据依赖和上下游依赖的串行任务，如文档总结类任务，这种情况下无法直接进行并行化。例如，你必须先从文档中提取关键信息，然后才能基于这些信息进行概括和总结。在这种情况下，这两个步骤必须顺序执行。

这些专门针对大模型特性的优化方案，能帮助你从多个维度解决大模型耗时问题，在复杂的工程实践中游刃有余，全面提升系统性能。
