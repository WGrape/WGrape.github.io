---
layout:     post
title:      实现PHP代码执行的记录与分析
header-img: /img/post.png
catalog: true
tags:
- PHP
---

> 文章内容更新请以 [WGrape GitHub博客 : 实现PHP代码执行的记录与分析](https://github.com/WGrape/Blog/issues/2) 为准

# 一、概览
在项目流程中，测试环节是避免错误的最后一道保障，后续环节中的各种服务监控、安全措施都只能减轻错误，而无法避免，所以测试环节的重要性值得高度重视。针对此环节进行优化，也便是本文的主要目的，文章会尽力用最精简的语言和最简单的图画来论述表达主旨。
![image.png](https://cdn.nlark.com/yuque/0/2020/png/223819/1598017879082-95b3030a-92e8-465f-a408-629e0964a73c.png#align=left&display=inline&height=210&margin=%5Bobject%20Object%5D&name=image.png&originHeight=419&originWidth=1400&size=51771&status=done&style=shadow&width=700)
下文会首先从测试角度介绍两个目标问题，并剖析二者的本质。最后在提出解决方案的同时，规划PHP代码执行记录与分析的作用价值，以实现更多切实可用的目标。
![image.png](https://cdn.nlark.com/yuque/0/2020/png/223819/1598017951472-5bfd824a-5625-4c8e-b2a6-d92c3d95c368.png#align=left&display=inline&height=163&margin=%5Bobject%20Object%5D&name=image.png&originHeight=325&originWidth=1920&size=71978&status=done&style=shadow&width=960)
# 二、目标问题
## 1. 日志无法定位原因
如何获取程序的执行记录，解决日志无法定位的问题，提高排查效率。
![image.png](https://cdn.nlark.com/yuque/0/2020/png/223819/1598018025690-c22dec28-6463-40b2-9099-2e2fc4d1a7fa.png#align=left&display=inline&height=170&margin=%5Bobject%20Object%5D&name=image.png&originHeight=340&originWidth=1458&size=50948&status=done&style=shadow&width=729)
## 2. 测试缺少代码覆盖率
如何在不需要任何额外人力投入的情况下，无论什么类型的测试，也能实现自动输出代码覆盖率 ？
![image.png](https://cdn.nlark.com/yuque/0/2020/png/223819/1598018094601-3e179135-bc94-45d5-afe2-66988ce5ad16.png#align=left&display=inline&height=262&margin=%5Bobject%20Object%5D&name=image.png&originHeight=524&originWidth=1584&size=64825&status=done&style=shadow&width=792)
# 三、问题剖析
## 1. 分析本质
上述两个目标问题的本质是，如何在不需要任何额外人力投入的情况下记录代码的执行，包括已执行的函数、代码等。
![image.png](https://cdn.nlark.com/yuque/0/2020/png/223819/1597846877376-06d877ca-0f97-46db-a6cb-0714fe36dd31.png#align=left&display=inline&height=240&margin=%5Bobject%20Object%5D&name=image.png&originHeight=828&originWidth=2484&size=114602&status=done&style=shadow&width=720)
## 2. 如何解决
Xdebug是PHP程序调试级别扩展，其提供的get_code_coverage方法会返回程序执行记录，其中1表示此行代码已执行，-1表示此行代码未执行，-2表示此行代码无法执行。

![image.png](https://cdn.nlark.com/yuque/0/2020/png/223819/1597849932099-0a91dfbc-61a8-4546-82e9-ae9b34d23d0d.png#align=left&display=inline&height=133&margin=%5Bobject%20Object%5D&name=image.png&originHeight=392&originWidth=2068&size=104997&status=done&style=shadow&width=700)
由于Xdebug返回的数据过于简单，无法快速获知已执行代码所在的目录、文件、函数、行号等信息。所以需要在其基础上进行较复杂的数据处理过程，直到转化为高级数据，高级数据是描述代码执行记录的最终状态。
![image.png](https://cdn.nlark.com/yuque/0/2020/png/223819/1598018260144-287ab105-eb1b-4f4d-bd18-e5b4766c6269.png#align=left&display=inline&height=146&margin=%5Bobject%20Object%5D&name=image.png&originHeight=352&originWidth=1692&size=37343&status=done&style=shadow&width=700)
## 3. 业务投射
在业务中应用上述方案需特殊处理，实现对于每个业务请求，都自动生成对应的描述代码执行记录的高级数据，这样的数据也称为RunInfo数据。
![image.png](https://cdn.nlark.com/yuque/0/2020/png/223819/1598018312734-468c4f01-9f79-4058-8479-deb7de7b2433.png#align=left&display=inline&height=152&margin=%5Bobject%20Object%5D&name=image.png&originHeight=322&originWidth=1486&size=38395&status=done&style=shadow&width=700)
可以从生命周期、存储位置、内容信息等方面认识RunInfo数据，此外应该明确其不是日志且二者区别界限明显。
![image.png](https://cdn.nlark.com/yuque/0/2020/png/223819/1598287966685-d21ac5e7-b901-40e2-9611-cce33ec129bc.png#align=left&display=inline&height=280&margin=%5Bobject%20Object%5D&name=image.png&originHeight=860&originWidth=2150&size=141933&status=done&style=shadow&width=700)
在实际应用中日志数据与RunInfo数据的关系是并列共存的关系，且都以logID为索引。不过因技术限制，RunInfo数据未使用收集等此类过程，暂仅以普通文件读写的方式存储在业务目录下。
![image.png](https://cdn.nlark.com/yuque/0/2020/png/223819/1598363385119-9e93d559-d6f0-45f7-90ba-67359e6f44e0.png#align=left&display=inline&height=226&margin=%5Bobject%20Object%5D&name=image.png&originHeight=642&originWidth=1986&size=53845&status=done&style=shadow&width=700)
## 4. 归纳总结
问题本质的可解性和可应用性已经确定，先暂告一段落。现重新回归文章的标题和中心思想，强调对PHP代码的执行增加两个操作，分别是记录和分析。其中记录部分在前文得到的高级数据中已经实现，剩下的分析部分，简言之就是对记录部分的数据使用分类、统计、计算等处理，下文会继续表述。
![image.png](https://cdn.nlark.com/yuque/0/2020/png/223819/1598205771842-ec6ae2e2-63ae-4a6f-86cd-6d15e09c6c38.png#align=left&display=inline&height=198&margin=%5Bobject%20Object%5D&name=image.png&originHeight=490&originWidth=1734&size=56253&status=done&style=shadow&width=700)
# 四、设计方案
## 1. 思路总览
### (1) 思想
为实现文章中心思想的最终结果，本方案的设计根本思想也是基于数据处理和数据分析，其中数据处理的产物是记录性信息，数据分析的产物是分析性信息。
![image.png](https://cdn.nlark.com/yuque/0/2020/png/223819/1598018369503-a9271bb6-e005-46cd-8b8b-c91803be41e2.png#align=left&display=inline&height=216&margin=%5Bobject%20Object%5D&name=image.png&originHeight=504&originWidth=1632&size=38714&status=done&style=shadow&width=700)
### (2) 架构
按流程分为三端，在测试端正常进行日常测试工作的同时，业务端的Code Coverage模块此时会根据请求的Logid自动生成对应的RunInfo数据储存下来，并提供代理接口来完成对业务代码的读取和对RunInfo数据的检索，实现PHP代码执行的记录与分析，最终通过平台端把一切相关的输出都可视化展示给用户。
![image.png](https://cdn.nlark.com/yuque/0/2020/png/223819/1598365237579-6d9d1ad7-a725-4fae-b530-ca42fff4adcd.png#align=left&display=inline&height=383&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1288&originWidth=2352&size=274690&status=done&style=shadow&width=700)
### (3) 测试端
在测试端的任何测试行为，可以照例如常，不需要发生任何变化。
### (4) 业务端
业务端新增的Code Coverage模块，是整个业务端的核心枢纽，一方面会生成最重要的RunInfo数据，另一方面负责对RunInfo数据分析。
![image.png](https://cdn.nlark.com/yuque/0/2020/png/223819/1598018465636-b76ed3e7-48e3-489f-8059-dc9021354333.png#align=left&display=inline&height=214&margin=%5Bobject%20Object%5D&name=image.png&originHeight=452&originWidth=1478&size=37421&status=done&style=shadow&width=700)

### (5) 平台端

在平台端提供基于Logid查询的Run Trace平台，为了实现将每次请求的代码执行记录和分析信息可视化展示给用户，需要业务端需要提供代理接口来解决无法直接读取业务代码的问题。
![image.png](https://cdn.nlark.com/yuque/0/2020/png/223819/1597912269569-4dd5defd-8487-4265-9b2f-ad1db2fb2783.png#align=left&display=inline&height=507&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1974&originWidth=2726&size=258742&status=done&style=shadow&width=700)
## 2. 业务端原理
### (1) 配置化
模块以配置化的方式驱动，配置项主要如下：

| 配置项 | 配置类型 | 描述 | 说明 |
| --- | --- | --- | --- |
| switch | String | 控制Code Coverage模块开启的开关 | 设置在各个环境是否开启 |
| allowlist | Array | 控制是否统计的白名单，支持目录、文件、函数三种级别 | 设置不需要被记录的代码 |
| denylist | Array | 控制是否统计的黑名单，支持目录、文件、函数三种级别 | 设置不需要被记录的代码 |
| valid_line_expr | Array | 无效行匹配，支持正则表达式 | 设置影响统计的代码，如空白行、注释等 |

### (2) 数据处理
#### ① 如何生成
在每个接口主任务的前后会分别执行Code Coverage模块提供的start和end方法，其中start方法完成模块启动相关的预处理工作，end方法生成每次请求对应的RunInfo数据。
![image.png](https://cdn.nlark.com/yuque/0/2020/png/223819/1598375642162-2b710039-fb4a-4d1d-aef2-fb36d49d3371.png#align=left&display=inline&height=258&margin=%5Bobject%20Object%5D&name=image.png&originHeight=604&originWidth=1636&size=63393&status=done&style=shadow&width=700)
#### ② 如何转化
现低级数据到高级数据的转化处理主要有如下两个级别过程：

- 文件级别的数据处理首先进行，使用双层循环处理Xdebug返回的数据，把所有已执行、未执行、无法执行的行号统一整理
- 函数级别的处理会在文件级别处理的基础上，通过反射获取每个类的所有函数及函数所在的行号范围，最终只记录已执行的函数信息

#### ③ 如何组成
RunInfo数据主要由Business、Coverage、Trace三部分构成，但由于技术限制导致Trace数据暂无法实现。
![image.png](https://cdn.nlark.com/yuque/0/2020/png/223819/1598637137232-3acdc53f-682f-4042-bbdf-0f16ce810288.png#align=left&display=inline&height=256&margin=%5Bobject%20Object%5D&name=image.png&originHeight=864&originWidth=2360&size=158057&status=done&style=shadow&width=700)
#### ④ 如何清理

- 在QA环境由于是Docker部署，每次发布都会重新更新环境，所以对应的RunInfo数据也会被清理掉，不需要特殊处理
- 在DEV环境，需要用脚本自动清理或者人工维护定时清理
### (3) 数据分析
数据分析主要包括分析RunInfo数据和业务代码的读取，通常使用二者结合的方式来提高分析的精度和与业务代码相关的展示。
![image.png](https://cdn.nlark.com/yuque/0/2020/png/223819/1598019137960-f41c9937-1fbc-402a-ac5b-482bdd22e313.png#align=left&display=inline&height=195&margin=%5Bobject%20Object%5D&name=image.png&originHeight=492&originWidth=1892&size=72279&status=done&style=shadow&width=750)
## 3. 预期目标
### (1) 分析接口业务信息
通过在平台端输入Logid，业务端的代理接口检索对应的business数据，实现接口的业务分析。
![image.png](https://cdn.nlark.com/yuque/0/2020/png/223819/1597601974078-0231c5a3-1e33-48ca-ba72-4d2fd5606b51.png#align=left&display=inline&height=153&margin=%5Bobject%20Object%5D&name=image.png&originHeight=308&originWidth=1410&size=24218&status=done&style=shadow&width=700)
### (2) 分析接口内部执行
通过在平台端输入Logid，业务端的代理接口检索对应的Coverage数据和Trace数据( 暂未实现 )，实现接口的内部执行分析。
![image.png](https://cdn.nlark.com/yuque/0/2020/png/223819/1597602022838-087539c1-b932-4960-ac12-24ce0424c9c3.png#align=left&display=inline&height=148&margin=%5Bobject%20Object%5D&name=image.png&originHeight=296&originWidth=1404&size=30076&status=done&style=shadow&width=702)
### (3) 分析接口的测试覆盖率
通过在平台端输入同一接口的多个不同logid，业务端的代理接口检索后合并所有的Coverage数据，最终生成多个请求合并后的最终代码执行记录，实现测试用例的代码覆盖率计算。
![image.png](https://cdn.nlark.com/yuque/0/2020/png/223819/1597602094079-4405d7e4-08b4-43af-bdc5-0393b86e0028.png#align=left&display=inline&height=222&margin=%5Bobject%20Object%5D&name=image.png&originHeight=554&originWidth=1748&size=94053&status=done&style=shadow&width=700)
# 五、实际应用
## 1. 前言
根据下列应用实际场景，以新增的Test_coverage接口为例，分别从问题描述、处理过程、最终结论三方面来阐述如何解决现实问题。
## 2. 分析接口加载
### (1) 问题描述
Test_coverage接口内部加载了很多无用的类库，现需要对Test_coverage接口进行加载代价分析，明确可以把哪些未使用的类库删除，精简代码。
```php
<?php
class Test_coverage extends Base_controller
{
    protected $testLib1;
    protected $testLib2;
    protected $testLib3;

    protected function _preload()
    {
        $this->testLib1 = &load_app('test_lib1', 'libraries');
        $this->testLib2 = &load_app('test_lib2', 'libraries');
        $this->testLib3 = &load_app('test_lib3', 'libraries');
    }

    public function _doaction(){
        // do nothing
    }
}
```
### (2) 处理过程
请求Test_coverage接口，在“平台端-接口性能”模块，输入请求对应的logid，查询得到如下信息。经分析发现接口共加载了3个冗余类库，即加载了这个类但是从未调用过。
![image.png](https://cdn.nlark.com/yuque/0/2020/png/223819/1598621029373-68781818-df81-455f-ad1d-e8e3b0f8059a.png#align=left&display=inline&height=169&margin=%5Bobject%20Object%5D&name=image.png&originHeight=692&originWidth=2858&size=117061&status=done&style=shadow&width=700)
### (3) 最终结论
通过接口性能查询服务，可以简便的获取到接口所加载的所有文件和冗余加载信息，为优化代码提供可用的分析方案。
## 3. 高效排查问题
### (1) 问题描述
业务代码和接口输出如下所示，Test_coverage接口代码中已经是最新的逻辑，本地调试也输出 `a <= b`，但为什么QA环境的执行却输出 `a < b` 呢？
```php
<?php
class Test_coverage extends Base_controller
{
    public function _doaction(){
        $this->calculate(17, 27);
    }

    public function calculate($a, $b){
        if ($a > $b) {
            $this->_result['result'] = 'a > b';
        } else {
            $this->_result['result'] = 'a <= b';
        }
    }
}
```
```json
{
    "errno": 0,
    "errmsg": "SUCCESS",
    "status": 0,
    "result": "a < b",
    "user_msg": ""
}
```
### (2) 处理过程
根据请求产生的logid，在“平台端-执行记录”模块，找到或输入对应的logid，会得到如下信息。
![image.png](https://cdn.nlark.com/yuque/0/2020/png/223819/1598620345105-a3faaf94-c924-495d-8d66-31db472e106c.png#align=left&display=inline&height=302&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1238&originWidth=2874&size=249421&status=done&style=shadow&width=700)
点击logid对应的一条请求记录，会跳转到如下页面，视图中会展示出源码，以下被高亮展示的部分就是在QA环境中已执行过的代码。
![image.png](https://cdn.nlark.com/yuque/0/2020/png/223819/1598629587585-974b20f4-c568-4005-b247-6a1075a14660.png#align=left&display=inline&height=526&margin=%5Bobject%20Object%5D&name=image.png&originHeight=2059&originWidth=2739&size=298842&status=done&style=shadow&width=700)
从中能够清晰的看到在QA环境中执行的代码是 `'a < b'` 而不是 `'a <= b'` ，所以可以断定此问题一定是QA环境未正确部署代码所致。
### (3) 最终结论
上述用最简单的一个例子来论证一个事实：如果能正确获知代码的执行记录，无论什么环境，都可以显著并大幅度提高排查问题的效率。
## 4. 评估测试用例
### (1) 问题描述
现需要测试Test_coverage接口，必传a、b两个参数，测试用例和代码如下，当前面临的问题是无法评估此组用例的测试覆盖率。

| 测试用例 | 参数 |
| --- | --- |
| Case 1 | a = 17 、b = 27 |
| Case 2 | a = 27 、b = 17 |

```php
<?php
class Test_coverage extends Base_controller
{
    public function _checkparams()
    {
        if (!isset($this->_params['a']) || !isset($this->_params['b'])) {
            throw new exception("param error", ERRNO_PARAMS_ERR);
        }
    }

    public function _doaction()
    {
        $a = $this->_params['a'];
        $b = $this->_params['b'];
        $this->calculate($a, $b);
    }

    public function calculate($a, $b)
    {
        if ($a > $b) {
            $this->_result['result'] = 'a > b';
        } elseif ($a == $b) {
            $this->_result['result'] = 'a = b';
        } else {
            $this->_result['result'] = 'a < b';
        }
    }
}
```
### (2) 处理过程
使用上述两个Case分别测试一次，在“平台端-执行记录”模块，把这两次测试对应的logid输入，系统会合并这两次请求的代码执行信息。然后得到的函数覆盖情况如下所示，总覆盖率为 ：(50+100+66.7)/3 = 72.2%。
![image.png](https://cdn.nlark.com/yuque/0/2020/png/223819/1598632683200-daf75939-8ed5-4849-88e7-6e620afdd9cf.png#align=left&display=inline&height=627&margin=%5Bobject%20Object%5D&name=image.png&originHeight=2491&originWidth=2782&size=389887&status=done&style=shadow&width=700)
由于覆盖率还较低，故再新增下列3种用例重新测试，重复上述输入logid的过程，最终得到下图函数覆盖信息，总覆盖率为 (100+100+100)/3 = 100%。

| 附加测试用例 | 参数 |
| --- | --- |
| 测试用例3 | a=17（无参数b） |
| 测试用例4 | b=27（无参数a） |
| 测试用例5 | a=17、b=17 |

![image.png](https://cdn.nlark.com/yuque/0/2020/png/223819/1598633206135-a38e1c5d-7670-4ca2-88bc-b7234e2ff212.png#align=left&display=inline&height=592&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1956&originWidth=2311&size=238941&status=done&style=shadow&width=700)
### (3) 最终结论
通过测试覆盖率结果，可以评估当前测试用例的好坏，通过不断丰富和优化测试用例，最终可设计出一组高测试覆盖率的用例。
# 六、结束与规划
本文主要介绍了通过使用基于数据处理、数据分析的技术方案，解决测试环节中的两个目标问题，在优化环节质量的同时，实现PHP代码执行记录与分析，以解决未来面对的更多问题。
