---
layout:     post
title:      《从实践中探究Redis原理》之Set一定是无序的吗（下）
header-img: /img/post.png
catalog: true
tags:
- Redis
---

> 文章内容更新请以 [WGrape GitHub博客 : 《从实践中探究Redis原理》之Set一定是无序的吗（下）](https://github.com/WGrape/Blog/issues/182) 为准

### 前言
本文原创，著作权归[WGrape](https://github.com/WGrape)所有，未经授权，严禁转载

# <span id="6">六、深入探究IntSet原理</span>

## <span id="61">1、预备知识</span>

### <span id="611">(1) 大小端字节序转换</span>
在计算机中，数据的存储模式有大端和小端两种模式。

<img width="555" alt="image" src="https://user-images.githubusercontent.com/35942268/169682660-315aa963-d3c7-433c-8d8f-eeae60bb0f38.png">

#### 大端模式（Big endian）
地址由小向大增加，数据从高位往低位放。这样按照地址递增顺序依次取出的数据，也是按照从高到低的顺序，这种数据处理顺序和字符串处理顺序一致，符合人的阅读顺序。

#### 小端模式（Little endian）
地址由小向大增加，数据从低位往高位放。这样按照地址递增顺序依次取出的数据，就会按照从低到高的顺序，这种处理顺序类似于从右向左的处理顺序。

### <span id="612">(2) Redis小端到大端的转换</span>
在Redis中的源码代码中，主要通过 ```*rev16ifbe```/```*rev32ifbe```/```*rev64ifbe``` 几个函数实现。

```c
/* variants of the function doing the actual conversion only if the target host is big endian */
#define memrev16ifbe(p) memrev16(p)
#define memrev32ifbe(p) memrev32(p)
#define memrev64ifbe(p) memrev64(p)
#define intrev16ifbe(v) intrev16(v)
#define intrev32ifbe(v) intrev32(v)
#define intrev64ifbe(v) intrev64(v)

/* Toggle the 16 bit unsigned integer pointed by *p from little endian to big endian */
void memrev16(void *p) {
    unsigned char *x = p, t;

    t = x[0];
    x[0] = x[1];
    x[1] = t;
}

/* Toggle the 32 bit unsigned integer pointed by *p from little endian to big endian */
void memrev32(void *p) {
    unsigned char *x = p, t;

    t = x[0];
    x[0] = x[3];
    x[3] = t;
    t = x[1];
    x[1] = x[2];
    x[2] = t;
}
```

以```memrev16()```函数为例，它的底层会通过使用一个8位的指针，以8位（1字节）为一个单位，依次交换两边的数据，实现小端和大端之间的转换。

<img width="900" alt="image" src="https://user-images.githubusercontent.com/35942268/169686520-24ca96c6-e2e0-4bfc-ab4b-6ea87b85ea71.png">

## <span id="62">2、IntSet的编码</span>
### <span id="621">(1) 为什么要区分编码</span>
在上篇文章中讲过，如果Set中都是整型数字且数量少于512个的时候，Redis会使用IntSet结构。让我们估算下内存开销情况 ：

- 假设一个整型数字占8个字节，那么1个Key就会占用```512*8=4096=0.004MB```，10w个Key就会占用400MB
- 假设一个整型数字占4个字节，那么1个Key就会占用```512*4=2048=0.002MB```，10w个Key就会占用200MB
- 假设一个整型数字占2个字节，那么1个Key就会占用```512*2=1024=0.001MB```，10w个Key就会占用100MB

很明显，对于不同的整型数字，使用合理的类型（如short、int、long），几乎可以省去近一半的内存。所以Redis为了减小内存存储，在设计IntSet结构时，对于不同的整型数字使用了不同的编码。

### <span id="622">(2) 编码类型</span>
IntSet中一共有```int16```/```int32```/```int64```/三种编码类型，分表表示16位、32位、64位整数。

```c
/* Note that these encodings are ordered, so:
 * INTSET_ENC_INT16 < INTSET_ENC_INT32 < INTSET_ENC_INT64. */
#define INTSET_ENC_INT16 (sizeof(int16_t))
#define INTSET_ENC_INT32 (sizeof(int32_t))
#define INTSET_ENC_INT64 (sizeof(int64_t))
```

<img width="820" alt="image" src="https://user-images.githubusercontent.com/35942268/169691477-39042524-3b5f-4354-bdac-210e781f955d.png">

### <span id="623">(3) 值的类型定义</span>
如果使用```int16_t```或```int32_t```类型来接收Value值，都会有数据溢出的风险，导致数据错误。所以源码中在对IntSet类型结构进行操作时，值的类型定义都是```int64_t value```，即使用```int64_t```类型来接收任意Value值，再根据当前编码类型进行转换即可。

### <span id="624">(4) 计算编码</span>
计算编码的方法很简单，只是判断下当前数字所在的整型范围即可。注意```INT32_MIN```和```INT16_MIN```都是负数，而且它们的绝对值是与```INT32_MAX```和```INT16_MAX```一样的。

<img width="443" alt="image" src="https://user-images.githubusercontent.com/35942268/169692989-782e20c6-26ea-4b38-a263-91867cf1f04a.png">

### <span id="625">(5) 编码升级</span>
现在考虑一个问题，假设当前选择的编码为int16，如果出现了一个比int16范围大的数字，那么这个数字肯定是无法存下去的。这时就需要对IntSet的contents数组做编码升级操作。

### <span id="626">(6) 升级过程</span>
在向集合中添加数字的时候，如果当前数字的范围超过当前IntSet的编码范围，就会触发编码升级的操作。

<img width="585" alt="image" src="https://user-images.githubusercontent.com/35942268/169691662-10e14bec-1e94-4f8a-9318-c2f4e84cc129.png">

在源码中，```intsetUpgradeAndAdd()```函数完成编码升级过程主要有如下操作 ：

- 根据新插入的Value值计算升级后的编码
- 设置新的编码并调整contents数组大小
- 从后到前升级依次调整contents数组中的元素编码
- 直接把新的Value值插入到contents数组中的首位（负数）或末尾（正数），因为新Value的绝对值一定是数组中最大的。

## <span id="63">3、核心API精讲</span>
### <span id="631">(1) intsetNew</span>
创建一个新的IntSet结构，并完成初始化工作。

- 使用```zmalloc()```分配内存，并返回指针
- 初始化IntSet结构时使用int16编码
- 长度初始化为0

<img width="383" alt="image" src="https://user-images.githubusercontent.com/35942268/168333936-b12cea76-ed8f-42f5-80f4-d3cb31c86912.png">

#### 为什么初始编码为int16
默认情况下，为了最大可能的减少内存占用，编码会先使用最小的类型，即int16

### <span id="632">(2) intsetAdd</span>
当插入一个元素到IntSet中时，会先计算当前要插入元素的编码，如果大于当前IntSet的编码，则进行编码升级和插入操作。否则只完成元素的插入操作，插入过程主要如下 ：

- 搜索元素是否已存在，存在则直接跳过
- 如果不存在，则返回要插入的位置pos，并调整contents数组的长度，即完成长度加1的操作，以插入新的元素
- 从pos位置开始的元素都整体向后（右）移动一个单元，之后再把元素插入到空闲出来的pos位置上
- 至此，插入操作结束

<img width="577" alt="image" src="https://user-images.githubusercontent.com/35942268/168335690-d05c57ee-5311-4620-bdef-e0b16a078ac4.png">

### <span id="633">(3) intsetRemove</span>
当移除IntSet中的一个元素时，会巧妙的先比较当前IntSet编码和移除元素的编码，如果小于则说明一定不存在于contents数组中，否则才会进行搜素。

- 搜素到元素所在的位置pos
- 从pos+1位置开始的元素都整体前前（左）移动一个单元，这样pos位置的元素就被覆盖了，达到了删除的效果
- 由于左移动后空出了一个单元，所以最后会调整contents数组的长度，即完成长度减1的操作
- 至此，删除操作结束

<img width="593" alt="image" src="https://user-images.githubusercontent.com/35942268/169648816-e02c93d7-acd5-4191-a301-b1c2db2b0f7d.png">

### <span id="634">(4) intsetMoveTail</span>
由于IntSet结构的插入和删除操作，需要涉及到一段连续contents单元的整体移动，所以```intsetMoveTail()```函数会主要使用```memmove()```库函数实现一段连续contents单元的整体移动。

<img width="522" alt="image" src="https://user-images.githubusercontent.com/35942268/169703113-813f77d6-f808-4fde-987c-b8b221ed6393.png">

#### 插入元素
当插入元素时，内存空间的移动如图所示

<img width="1000" alt="image" src="https://user-images.githubusercontent.com/35942268/169703982-f5f0a968-5675-46ca-8010-3c3e2a6e2925.png">

#### 删除元素
当删除元素时，内存空间的移动如图所示

<img width="1000" alt="image" src="https://user-images.githubusercontent.com/35942268/169704079-2ce3ab3d-1192-402c-8a6d-0507bc19a40c.png">

### <span id="635">(5) intsetSearch</span>
查找IntSet中的元素时，主要使用二分法查找，并找到元素要插入的位置。

<img width="573" alt="image" src="https://user-images.githubusercontent.com/35942268/169648921-f3469c29-bef1-4574-9a24-5683cc9298a4.png">

# <span id="7">七、IntSet结构的优势</span>
从实际上看，IntSet相比于HashTable主要具有如下优势。

## <span id="71">1、类型简单</span>
HashTable结构不但需要维护一个复杂的dict结构，还需要处理扩容问题。而IntSet的核心只需要维护一个简单的contents数组即可。

## <span id="72">2、节省内存空间</span>
IntSet结构不但只有contents、encoding、length三个属性，而且还针对不同范围的整型数字设计了不同的编码处理。而HashTable复杂的dict结构，在同等量级的数据下，会多占用30%甚至更多的内存空间。

## <span id="73">3、综合性能乐观</span>
由于contents是一个有序的数组，在查找时使用二分算法（O(logN)），虽然慢于HashTable的常数级查找，但IntSet结构在内存占用和维护上是优于HashTable的。所以综合性能十分乐观。

# <span id="8">八、问题解答</span>

## <span id="81">1、Redis Set是否有序</span>
Set集合的定义是无序的，但是Redis底层做了优化，当元素都是整型且不超过512个的时候，会使用IntSet结构，而IntSet结构是有序的。一旦打破这个规则，Redis便会使用Hash结构，这时Set就不再是一个有序的结构了。

## <span id="82">2、IntSet的有序是指什么</span>
IntSet的有序指的是它底层的contents数组是按照升序排列的。注意不是插入顺序，也不是降序，而是升序 ！

<img width="218" alt="image" src="https://user-images.githubusercontent.com/35942268/169705078-a22d801b-47e5-4de9-9c69-638d786d5c53.png">

# <span id="9">九、完结</span>
至此，《从实践中探究Redis原理》中的Set类型系列文章已经结束，如有问题欢迎评论指出，感谢阅读。
