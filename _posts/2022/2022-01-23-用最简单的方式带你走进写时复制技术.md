---
layout:     post
title:      用最简单的方式带你走进写时复制技术
header-img: /img/post.png
catalog: true
tags:
- CopyOnWrite
---

> 文章内容更新请以 [WGrape GitHub博客 : 什么是Copy-on-write技术](https://github.com/WGrape/Blog/issues/17) 为准


### 前言
本文原创，著作权归[WGrape](https://github.com/WGrape)所有，未经授权，严禁转载

### 阅读指南
阅读此篇文章，你能从中学到什么 ？

- 理解写时复制技术
- 写时复制的应用场景

## <span id="1">一、介绍</span>
在程序的**内存优化**技术中，有一种名为```Copy-on-write```（COW）的写时复制技术，它可用于避免不必要的内存拷贝，以提高内存的利用率。

## <span id="2">二、理解</span>
写时复制的思想是当多个调用者请求同一个资源时，所有调用者都会获取到一个指向这个资源的指针，直到某调用者对资源进行修改时，系统才会复制一份资源给此调用者。正是通过这种避免不必要的内存拷贝，减少了内存整体开销。

为了更透彻的理解这种技术，可以看如下程序，代码中定义了 str1 和 str2 这两个字符串，且第二个字符串一直和第一个内容一样，但直到程序退出结束，str2字符串的内容也未曾改变。

```c
int main(){
    str1 = "hello world";
    str2 = str1;

    // ... ...

    return 0;
}
```

### <span id="21">1、内存优化前</span>
在未优化前，内存使用情况如下所示，两个字符串都占用了不同的内存空间。

<img src="https://user-images.githubusercontent.com/35942268/150673421-a9ba12ba-fde7-4406-83fe-3608eea96b9a.png" width="377">

### <span id="22">2、内存优化后</span>
在使用写时复制技术优化后，初始时两个字符串都共享同一个内存空间，只有当S2字符串出现写操作时，才会从内存中复制一个新的内存区域给S2使用。

也就是说只有当真正发生写操作时，才会有自己独享的可写内存，否则会使用共享的内存。

<img src="https://user-images.githubusercontent.com/35942268/150673591-0d6a45a8-b788-4527-b960-5207a015cc3a.png" width="800">

## <span id="3">三、应用场景</span>

### <span id="31">1、数据结构</span>
在一些常用的如树、数组、链表等数据结构中，我们都可以使用写时复制技术。

#### <span id="311">(1) 重复节点压缩</span>
在如下链表中，第一个和第二个是完全一样的节点，如果在整个链表中大量存在这样重复的节点，会造成内存大量的浪费。

<img width="800" alt="image" src="https://user-images.githubusercontent.com/35942268/172043698-f6c4b967-5e45-4f87-9783-e42fc6951fdf.png">

为了减小整个链表的内存大小，我们可以借鉴写时复制的设计，为链表增加一个```count```属性表示相同节点的数量，在程序中需要实际修改节点的时候，才把节点创建出来。

<img width="856" alt="image" src="https://user-images.githubusercontent.com/35942268/172043792-bb35b810-2f82-4e8c-82eb-ffba356cf0e7.png">

### <span id="32">2、Linux进程</span>

在Linux进程实现中，进程fork出子进程时，会复制父进程的数据，这种复制方式就是```Copy-on-write```。子进程并不会完全拷贝出一个完整的内存副本，而是只有当子进程对数据进行修改时，才会进行复制。

如下图中，父进程P在fork出Q子进程后，两个进程会共用一个内存空间，当父进程P修改页面3的数据时，系统会拷贝出一个页面3的副本，这样父进程就会修改页面3的副本数据，而不会对子进程有影响，实现进程间数据的隔离。

<img src="https://user-images.githubusercontent.com/35942268/150675604-227460ac-a241-49a2-bf49-019551746ee4.png" width="500">

### <span id="33">3、Redis内存优化</span>
一般地，在Redis多进程（如执行BGSAVE）的情况下，如果发生内存复制，会非常容易出现内存不足或耗尽的异常错误。为了减少内存复制，最根本的方法是减少写操作的发生，主要有以下优化手段。

- 在Redis写操作低峰时期，才允许进行BGSAVE
- rehash一定会发生写操作，所以Redis在多进程下会提高负载因子，减少rehash的出现，以减少写操作导致的内存复制
